#include "harvest_plugin.h"

bool eq(const char *p1, const char *p2) {
    const unsigned char *s1 = (const unsigned char *) p1;
    const unsigned char *s2 = (const unsigned char *) p2;
    unsigned char c1, c2;
    do {
        c1 = (unsigned char) *s1++;
        c2 = (unsigned char) *s2++;
        if (c1 == '\0') return (c1 - c2) == 0;
    } while (c1 == c2);

    return (c1 - c2) == 0;
}

#define _HARVEST(address, underlying_ticker, underlying_decimals, vault_ticker, vault_decimals) \
    {address, underlying_ticker, underlying_decimals, vault_ticker, vault_decimals},

const contract_info_t contracts[] = {
// this contracts-info.txt file is autogenerated by script:
// /tests/harvest/update-contracts-info-b2c.mjs
// or type: cd tests && npm run update-harvest

// #ifdef DEBUG
// Include vaults used in the tests
#include "contracts-info-tests.txt"
// #endif
#ifndef DEBUG
// this contracts-info.txt file is autogenerated by script:
// /tests/harvest/update-contracts-info-b2c.mjs
// or type: cd tests && npm run update-harvest
#include "contracts-info.txt"
#endif
};

contract_info_t *find_contract_info(const char *address) {

    int len = sizeof(contracts) / sizeof(contracts[0]);
    PRINTF("Contracts length: %d\n", len);
    for (int i = 0; i < len; i++) {
        contract_info_t *ci = (contract_info_t *) PIC(&contracts[i]);
        if (eq(address, (char *) PIC(ci->address))) return ci;
    }
    // when contract is not found
    return NULL;
}

void handle_finalize(void *parameters) {
    ethPluginFinalize_t *msg = (ethPluginFinalize_t *) parameters;
    context_t *context = (context_t *) msg->pluginContext;

    selector_t selectorIndex = context->selectorIndex;
    msg->numScreens = selectorIndex == POOL_GET_REWARD || selectorIndex == POOL_EXIT ? 1 : 2;

    // Fill context underlying and vault ticker/decimals
    char *addr = context->contract_address;
    addr[0] = '0';
    addr[1] = 'x';

    uint64_t chainId = 0;
    getEthAddressStringFromBinary(msg->pluginSharedRO->txContent->destination,
                                  addr + 2,  // +2 here because we've already prefixed with '0x'.
                                  msg->pluginSharedRW->sha3,
                                  chainId);
    PRINTF("MSG Address: %s\n", addr);

    contract_info_t *info = find_contract_info(addr);

    if (info == NULL) {  // if contract info is not found
        msg->result = ETH_PLUGIN_RESULT_UNAVAILABLE;

    } else {
        //         PRINTF("info.underlying decimals: %d, ticker: %s\n ",
        //                info->underlying_decimals,
        //                info->underlying_ticker);
        //         PRINTF("info.vault      decimals: %d, ticker: %s\n ",
        //                info->vault_decimals,
        //                info->vault_ticker);

        strlcpy(context->underlying_ticker,
                (char *) PIC(info->underlying_ticker),
                sizeof(context->underlying_ticker));
        context->underlying_decimals = info->underlying_decimals;
        strlcpy(context->vault_ticker,
                (char *) PIC(info->vault_ticker),
                sizeof(context->vault_ticker));
        context->vault_decimals = info->vault_decimals;

        msg->uiType = ETH_UI_TYPE_GENERIC;
        msg->result = ETH_PLUGIN_RESULT_OK;
    }
}
